# UnitPay 代码修改建议

为了解决订单创建后未自动调用USDT到合约的问题，以下是具体的代码修改建议。

## 1. 修改 `payment.js` 中的 `createPayPalOrder` 函数

### 当前代码
```javascript
async function createPayPalOrder() {
    // ...创建订单逻辑...
    
    if (orderData.success) {
        // 标记订单已创建
        console.log('===DEBUG=== 设置paypalOrderCreated=true');
        paypalOrderCreated = true;
        
        // 保存PayPal订单ID到本地存储
        const orderId = orderData.data.paypalOrderId || orderData.data.id;
        localStorage.setItem('paypalOrderId', orderId);
        localStorage.setItem(`paypal_order_${paymentIntentId}`, orderId);
        console.log('===DEBUG=== 已保存订单ID到localStorage:', orderId);
        
        sessionStorage.setItem('paymentProcessing', 'true');
        console.log('===DEBUG=== 已设置sessionStorage.paymentProcessing=true');
        
        return orderId;
    }
}
```

### 建议修改为
```javascript
async function createPayPalOrder() {
    // ...现有订单创建逻辑保持不变...
    
    if (orderData.success) {
        // 标记订单已创建
        console.log('===DEBUG=== 设置paypalOrderCreated=true');
        paypalOrderCreated = true;
        
        // 保存PayPal订单ID到本地存储
        const orderId = orderData.data.paypalOrderId || orderData.data.id;
        localStorage.setItem('paypalOrderId', orderId);
        localStorage.setItem(`paypal_order_${paymentIntentId}`, orderId);
        console.log('===DEBUG=== 已保存订单ID到localStorage:', orderId);
        
        sessionStorage.setItem('paymentProcessing', 'true');
        console.log('===DEBUG=== 已设置sessionStorage.paymentProcessing=true');
        
        // 新增：检查是否需要自动进行区块链操作
        if (document.getElementById('auto-blockchain-settlement')?.checked) {
            try {
                // 检查钱包连接状态
                if (!isWalletConnected()) {
                    console.log('===DEBUG=== 自动连接钱包');
                    await connectWallet();
                }
                
                // 自动授权USDT
                console.log('===DEBUG=== 自动授权USDT');
                await approveUSDT();
                
                // 自动结算支付
                console.log('===DEBUG=== 自动结算支付');
                await settlePaymentOnChain();
            } catch (error) {
                console.error('===DEBUG=== 自动区块链操作失败:', error);
                showError('自动处理区块链操作失败，请手动完成剩余步骤');
            }
        }
        
        return orderId;
    }
}
```

## 2. 添加自动化选项到HTML界面

在相关的HTML文件中添加自动化选项，例如在 `payment-detail.html` 中：

```html
<div class="form-group">
    <div class="custom-control custom-checkbox">
        <input type="checkbox" class="custom-control-input" id="auto-blockchain-settlement">
        <label class="custom-control-label" for="auto-blockchain-settlement">
            自动处理区块链交易（授权和结算）
        </label>
    </div>
    <small class="form-text text-muted">
        选中此项将在创建订单后自动连接钱包、授权USDT并结算支付。
    </small>
</div>
```

## 3. 改进 `approveUSDT` 函数以支持不同场景

### 当前代码
```javascript
async function approveUSDT() {
    const approveButton = document.getElementById('approve-usdt');
    const originalText = approveButton.textContent;
    approveButton.disabled = true;
    approveButton.textContent = '授权中...';

    try {
        // 获取订单金额
        const amount = parseFloat(document.getElementById('payment-amount').textContent);
        if (isNaN(amount)) {
            throw new Error('无效的支付金额');
        }

        // 检查当前授权额度
        const currentAllowance = await contractService.checkUSDTAllowance(contractService.networkConfig.ESCROW_ADDRESS);
        if (parseFloat(currentAllowance) >= amount) {
            // 已有足够的授权额度
            document.getElementById('step2-status').textContent = '已授权';
            document.getElementById('step2-status').className = 'step-status success';
            document.getElementById('settle-payment').disabled = false;
            return;
        }

        // 执行授权
        const txHash = await contractService.approveUSDT(amount);
        
        // 更新UI
        document.getElementById('step2-status').textContent = '已授权';
        document.getElementById('step2-status').className = 'step-status success';
        document.getElementById('settle-payment').disabled = false;
        
        showSuccess(`USDT授权成功！交易哈希: ${txHash}`);
    } catch (error) {
        console.error('USDT授权失败:', error);
        document.getElementById('step2-status').textContent = '授权失败';
        document.getElementById('step2-status').className = 'step-status error';
        showError(error.message || 'USDT授权失败，请重试');
    } finally {
        approveButton.disabled = false;
        approveButton.textContent = originalText;
    }
}
```

### 建议修改为
```javascript
async function approveUSDT(isAutomatic = false) {
    let approveButton;
    let originalText;
    
    // 仅在非自动模式下更新UI
    if (!isAutomatic) {
        approveButton = document.getElementById('approve-usdt');
        originalText = approveButton.textContent;
        approveButton.disabled = true;
        approveButton.textContent = '授权中...';
    } else {
        console.log('===DEBUG=== 自动模式授权USDT');
    }

    try {
        // 获取订单金额 - 灵活获取金额
        let amount;
        const amountElement = document.getElementById('payment-amount');
        if (amountElement) {
            amount = parseFloat(amountElement.textContent);
        } else if (paymentData && paymentData.amount) {
            amount = parseFloat(paymentData.amount);
        } else {
            throw new Error('找不到支付金额信息');
        }
        
        if (isNaN(amount)) {
            throw new Error('无效的支付金额');
        }

        // 检查当前授权额度
        const currentAllowance = await contractService.checkUSDTAllowance(contractService.networkConfig.ESCROW_ADDRESS);
        if (parseFloat(currentAllowance) >= amount) {
            // 已有足够的授权额度
            if (!isAutomatic) {
                document.getElementById('step2-status').textContent = '已授权';
                document.getElementById('step2-status').className = 'step-status success';
                document.getElementById('settle-payment').disabled = false;
            }
            return true; // 表示授权已完成
        }

        // 执行授权
        const tx = await contractService.approveUSDT(amount);
        
        // 等待交易确认
        console.log('===DEBUG=== 等待授权交易确认:', tx.hash);
        await tx.wait();
        
        // 更新UI
        if (!isAutomatic) {
            document.getElementById('step2-status').textContent = '已授权';
            document.getElementById('step2-status').className = 'step-status success';
            document.getElementById('settle-payment').disabled = false;
            showSuccess(`USDT授权成功！交易哈希: ${tx.hash}`);
        }
        
        return true; // 表示授权已完成
    } catch (error) {
        console.error('USDT授权失败:', error);
        if (!isAutomatic) {
            document.getElementById('step2-status').textContent = '授权失败';
            document.getElementById('step2-status').className = 'step-status error';
            showError(error.message || 'USDT授权失败，请重试');
        }
        throw error; // 向上传递错误以便自动流程可以处理
    } finally {
        if (!isAutomatic && approveButton) {
            approveButton.disabled = false;
            approveButton.textContent = originalText;
        }
    }
}
```

## 4. 改进 `settlePaymentOnChain` 函数以支持自动模式

### 当前代码
```javascript
async function settlePaymentOnChain() {
    const settleButton = document.getElementById('settle-payment');
    settleButton.disabled = true;
    settleButton.textContent = '结算中...';
    
    try {
        if (!paymentData) {
            throw new Error('支付数据不可用');
        }
        
        // 验证LP钱包地址
        if (!paymentData.lpWalletAddress || !/^0x[a-fA-F0-9]{40}$/.test(paymentData.lpWalletAddress)) {
            throw new Error('无效的LP钱包地址');
        }
        
        // 结算支付
        const result = await contractService.settlePayment(
            paymentData.lpWalletAddress,
            parseFloat(paymentData.amount),
            paymentData.id
        );
        
        if (!result.success) {
            throw new Error(result.error || '区块链结算失败');
        }
        
        // 更新UI
        document.getElementById('step3-status').textContent = '已结算';
        document.getElementById('step3-status').className = 'step-status success';
        
        // 显示交易结果
        document.getElementById('blockchain-result').classList.remove('hidden');
        document.getElementById('tx-hash').textContent = result.txHash;
        document.getElementById('tx-hash').href = `${contractService.networkConfig.BLOCK_EXPLORER}/tx/${result.txHash}`;
        document.getElementById('tx-status').textContent = '成功';
        
        // 向后端API报告链上结算成功
        await reportBlockchainSettlement(result.txHash);
        
        // 显示成功信息
        showSuccess('blockchain', { 
            id: paymentData.id,
            amount: paymentData.amount,
            txHash: result.txHash
        });
    } catch (error) {
        console.error('区块链结算错误:', error);
        showError(`区块链结算失败: ${error.message}`);
        
        // 恢复按钮状态
        settleButton.disabled = false;
        settleButton.textContent = '结算支付';
        
        // 显示交易结果（如果有）
        if (error.txHash) {
            document.getElementById('blockchain-result').classList.remove('hidden');
            document.getElementById('tx-hash').textContent = error.txHash;
            document.getElementById('tx-hash').href = `${contractService.networkConfig.BLOCK_EXPLORER}/tx/${error.txHash}`;
            document.getElementById('tx-status').textContent = '失败';
        }
    }
}
```

### 建议修改为
```javascript
async function settlePaymentOnChain(isAutomatic = false) {
    let settleButton;
    
    // 仅在非自动模式下更新UI
    if (!isAutomatic) {
        settleButton = document.getElementById('settle-payment');
        settleButton.disabled = true;
        settleButton.textContent = '结算中...';
    } else {
        console.log('===DEBUG=== 自动模式结算支付');
    }
    
    try {
        if (!paymentData) {
            throw new Error('支付数据不可用');
        }
        
        // 验证LP钱包地址
        if (!paymentData.lpWalletAddress || !/^0x[a-fA-F0-9]{40}$/.test(paymentData.lpWalletAddress)) {
            throw new Error('无效的LP钱包地址');
        }
        
        // 结算支付
        const result = await contractService.settlePayment(
            paymentData.lpWalletAddress,
            parseFloat(paymentData.amount),
            paymentData.id
        );
        
        if (!result.success) {
            throw new Error(result.error || '区块链结算失败');
        }
        
        // 更新UI
        if (!isAutomatic) {
            document.getElementById('step3-status').textContent = '已结算';
            document.getElementById('step3-status').className = 'step-status success';
            
            // 显示交易结果
            document.getElementById('blockchain-result').classList.remove('hidden');
            document.getElementById('tx-hash').textContent = result.txHash;
            document.getElementById('tx-hash').href = `${contractService.networkConfig.BLOCK_EXPLORER}/tx/${result.txHash}`;
            document.getElementById('tx-status').textContent = '成功';
        }
        
        // 向后端API报告链上结算成功
        await reportBlockchainSettlement(result.txHash);
        
        // 显示成功信息
        if (!isAutomatic) {
            showSuccess('blockchain', { 
                id: paymentData.id,
                amount: paymentData.amount,
                txHash: result.txHash
            });
        } else {
            // 自动模式下也显示成功信息，但使用不同的方式
            showInfo(`自动区块链结算成功，交易哈希: ${result.txHash}`);
        }
        
        return true; // 表示结算成功
    } catch (error) {
        console.error('区块链结算错误:', error);
        
        if (!isAutomatic) {
            showError(`区块链结算失败: ${error.message}`);
            
            // 恢复按钮状态
            if (settleButton) {
                settleButton.disabled = false;
                settleButton.textContent = '结算支付';
            }
            
            // 显示交易结果（如果有）
            if (error.txHash) {
                document.getElementById('blockchain-result').classList.remove('hidden');
                document.getElementById('tx-hash').textContent = error.txHash;
                document.getElementById('tx-hash').href = `${contractService.networkConfig.BLOCK_EXPLORER}/tx/${error.txHash}`;
                document.getElementById('tx-status').textContent = '失败';
            }
        } else {
            // 自动模式下显示错误通知
            showError(`自动区块链结算失败: ${error.message}`);
        }
        
        throw error; // 向上传递错误以便自动流程可以处理
    }
}
```

## 5. 添加事件触发机制

在适当的位置添加事件触发代码，使得订单创建后可以触发区块链操作：

```javascript
// payment.js 中添加事件触发函数
function triggerOrderCreatedEvent(orderData) {
    const event = new CustomEvent('orderCreated', {
        detail: {
            paymentId: orderData.id,
            lpAddress: orderData.lpWalletAddress,
            amount: orderData.amount,
            orderId: orderData.paypalOrderId
        }
    });
    document.dispatchEvent(event);
    console.log('===DEBUG=== 已触发订单创建事件:', event.detail);
}

// 添加事件监听
document.addEventListener('orderCreated', async (event) => {
    console.log('===DEBUG=== 收到订单创建事件:', event.detail);
    
    // 检查是否启用了自动区块链处理
    if (document.getElementById('auto-blockchain-settlement')?.checked) {
        try {
            // 自动处理区块链操作
            if (!isWalletConnected()) {
                await connectWallet();
            }
            
            await approveUSDT(true); // 传入true表示自动模式
            await settlePaymentOnChain(true); // 传入true表示自动模式
            
            console.log('===DEBUG=== 自动区块链处理完成');
        } catch (error) {
            console.error('===DEBUG=== 自动区块链处理失败:', error);
            showError('自动区块链处理失败，请手动完成剩余步骤');
        }
    }
});
```

## 6. 改进 ContractService 中的 settlePayment 方法

### 当前代码
```javascript
async settlePayment(lpAddress, amount, paymentId) {
    try {
      if (!this.contract || !this.walletAddress) {
        throw new Error("合约未初始化或钱包未连接");
      }
      
      // 验证参数
      if (!this.web3.utils.isAddress(lpAddress)) {
        throw new Error("无效的LP地址");
      }
      
      if (amount <= 0) {
        throw new Error("金额必须大于0");
      }
      
      if (!paymentId || paymentId.trim() === "") {
        throw new Error("支付ID不能为空");
      }
      
      // 转换为USDT的最小单位（6位小数）
      const amountInWei = this.web3.utils.toBN(Math.round(amount * 1000000));
      
      // 调用合约的settlePayment方法
      const tx = await this.contract.methods
        .settlePayment(lpAddress, amountInWei, paymentId)
        .send({ from: this.walletAddress });
      
      console.log("支付结算成功:", tx.transactionHash);
      return {
        success: true,
        txHash: tx.transactionHash
      };
    } catch (error) {
      console.error("支付结算失败:", error);
      return {
        success: false,
        txHash: null,
        error: error.message
      };
    }
}
```

### 建议修改为
```javascript
async settlePayment(lpAddress, amount, paymentId) {
    try {
      if (!this.isInitialized()) {
        // 尝试自动初始化
        try {
          await this.initializeWeb3();
          await this.initializeContracts();
        } catch (initError) {
          throw new Error(`合约初始化失败: ${initError.message}`);
        }
      }
      
      // 验证参数
      if (!ethers.utils.isAddress(lpAddress)) {
        throw new Error("无效的LP地址");
      }
      
      if (amount <= 0) {
        throw new Error("金额必须大于0");
      }
      
      if (!paymentId || paymentId.trim() === "") {
        throw new Error("支付ID不能为空");
      }
      
      // 检查USDT余额
      const balance = await this.getUSDTBalance();
      if (parseFloat(balance) < amount) {
        throw new Error(`USDT余额不足，当前余额: ${balance}，需要: ${amount}`);
      }
      
      // 检查授权额度
      const allowance = await this.checkUSDTAllowance(this.networkConfig.ESCROW_ADDRESS);
      if (parseFloat(ethers.utils.formatUnits(allowance, 6)) < amount) {
        throw new Error("USDT授权额度不足，请先授权");
      }
      
      console.log(`准备调用合约锁定资金: ${paymentId}, ${amount}, ${lpAddress}`);
      
      // 调用合约的lockFunds方法（而不是settlePayment）
      const tx = await this.escrowContract.lockFunds(
        paymentId, 
        ethers.utils.parseUnits(amount.toString(), 6), 
        lpAddress,
        { gasLimit: 300000 } // 添加一个合理的gasLimit
      );
      
      // 等待交易确认
      console.log("等待交易确认...");
      const receipt = await tx.wait();
      
      console.log("资金锁定成功:", receipt.transactionHash);
      return {
        success: true,
        txHash: receipt.transactionHash
      };
    } catch (error) {
      console.error("资金锁定失败:", error);
      return {
        success: false,
        txHash: null,
        error: error.message
      };
    }
}
```

## 7. 在初始化页面时添加代码检查是否有未完成的订单

在页面初始化函数中添加检查代码，以处理有未完成订单的情况：

```javascript
async function initPaymentPage() {
    // 其他初始化代码...
    
    // 检查是否有未完成的订单
    const paymentIntentId = localStorage.getItem('paymentIntentId');
    if (paymentIntentId) {
        const paypalOrderId = localStorage.getItem(`paypal_order_${paymentIntentId}`);
        if (paypalOrderId) {
            // 有未完成的订单，加载订单数据
            await loadPaymentDetails(paymentIntentId);
            
            // 如果启用了自动处理并且订单状态合适
            if (document.getElementById('auto-blockchain-settlement')?.checked && 
                paymentData && 
                (paymentData.status === 'created' || paymentData.status === 'processing')) {
                
                // 检查区块链交互是否已完成
                const isBlockchainSettled = paymentData.blockchainTxHash || 
                                         paymentData.status === 'settled' ||
                                         paymentData.escrowStatus === 'locked';
                
                if (!isBlockchainSettled) {
                    // 提示用户继续未完成的区块链交互
                    const shouldContinue = confirm('检测到有未完成的区块链交互，是否继续？');
                    if (shouldContinue) {
                        try {
                            if (!isWalletConnected()) {
                                await connectWallet();
                            }
                            
                            await approveUSDT(true);
                            await settlePaymentOnChain(true);
                        } catch (error) {
                            console.error('===DEBUG=== 自动完成未完成交互失败:', error);
                            showError('自动处理失败，请手动完成剩余步骤');
                        }
                    }
                }
            }
        }
    }
}

// 确保页面加载时调用初始化函数
document.addEventListener('DOMContentLoaded', initPaymentPage);
```

## 总结

上述修改建议的核心是将订单创建和区块链交互流程整合起来，提供自动化选项，同时保留手动操作的灵活性。主要修改点包括：

1. 在订单创建成功后支持自动触发区块链操作
2. 改进函数以支持自动模式和手动模式
3. 添加UI选项让用户选择是否自动执行区块链操作
4. 添加事件机制使组件间能更好地协同工作
5. 改进钱包连接和合约交互的可靠性
6. 添加未完成订单的处理逻辑

这些修改需要谨慎测试，特别是涉及区块链交互的部分，确保在各种情况下都能稳定运行。 